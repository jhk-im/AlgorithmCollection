# 무지의 먹방 라이브

## 문제 설명

* 회전판에 먹어야 할 N개의 음식이 있음
  * 각 음식에는 1부터 N까지 번호가 붙어있음
  * 각 음식을 섭취하는데 일정 시간이 소요됨
* 음식섭취 방법
  * 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식물을 가져다 놓음
  * 마지막 번호의 음식을 섭취한 후 다시 1번 음식물을 가져다 놓음
  * 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고 다음 음식을 섭취함
    * 남은 음식은 아직 남아 있는 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식
  * 회전판이 다음 음식을 가져오는데 걸리는 시간은 없다고 가정함
* 잠시 방송이 중단된 상태를 가정함
  * 방송 정상화 후 몇 번 음식부터 섭취해야 하는지 알고자 함
  * 모두 먹는데 필요한 시간이 담겨있는 food_times 배열이 제공됨
  * 네트워크 장개가 발생한 K초가 제공됨

`몇 번 음식부터 섭취하면 되는지 return 하도록 solution 함수를 완성하시오`

제한 사항

* food_times = 각 음식을 모두 먹는 데 필요한 시간이 음식의 번호 순서대로 들어있는 배열
* k는 방송이 중단된 시간을 나타냄
* 더 섭취해야 할 음식이 없는 경우 -1 반환

정확성 테스트 제한 사항

* 1 <= food_times 길이 <= 2,000
* 1 <= food_times 원소 <= 1,000 자연수
* 1 <= K <= 2,000,000 자연수

효율성 테스트 제한 사항

* 1 <= food_times 길이 <= 200,000
* 1 <= food_times 원소 <= 100,000,000 자연수
* 1 <= K <= 2 X 10² 자연수

입출력 예시

|food_times|k|result|
|-|-|-|
|[3, 1, 2]|5|1|

입출력 예시에 대한 설명

* 0 ~ 1초 동안 1번 음식섭취 => 남은시간 [2, 1, 2]
* 1 ~ 2초 동안 2번 음식섭취 => 남은시간 [2, 0, 2]
* 2 ~ 3초 동안 3번 음식섭취 => 남은시간 [2, 0, 1]
* 3 ~ 4초 동안 1번 음식섭취 => 남은시간 [1, 0, 1]
* 4 ~ 5초 동안 3번 음식섭취 => 남은시간 [1, 0, 0]
* 5초에서 트워크 장애 => 1번부터 다시 섭취

### 해결 과정

`해당 방식은 프로그래머스 효율성 테스트 통과하지 못함`

* 적게 걸리는 음식부터 확인하는 방식으로 해결
* 시간 기준으로 음식을 정렬
  * 적게 걸리는 음식부터 제거해 나가는 방식
* 우선순위 큐(최소힙)을 사용함

```txt
0.
* 전체 음식을 먹는 시간 <= K
  * 더 이상 먹을 음식이 없는 것으로 판단하여 -1 반환
* 음식 리스트 = [3, 1, 2]
* 최소힙에 (time, index) 형태로 추가
  * 음식 시간을 기준으로 가장 적은 순서대로 정렬
* 이전에 먹은 음식의 시간 P = 0
* 남은 음식 length = 음식리스트의 길이 3
* 먹기위해 사용한 시간 T = 0
````

|최소힙|(1, 2) / (2,3) / (3,1)|
|-|-|
|K|5초|
|length|3개|
|P|0초|
|T|0초|

```txt
1.
* (1, 2) Pop
  * T
    * 현재 음식의 시간 C = 1
    * T + (C - P) * length = 3
  * length - 1 = 2개
  * P = C

````

|최소힙|(2,3) / (3,1)|
|-|-|
|K|5초|
|length|2개|
|P|1초|
|T|2초|

```txt
2.
* (2, 3) Pop
  * T
    * 현재 음식의 시간 C = 2
    * T + (C - P) * length = 5
  * length = 1개
  * P = C
* K만큼 먹는 시간을 소요했으므로 반복문 탈출
````

|최소힙|(3,1)|
|-|-|
|K|5초|
|length|1개|
|P|2초|
|T|5초|

```txt
3.
* 최소힙에 남아 있는 데이터를 배열에 담아 음식 번호 기준으로 정렬
* return = array[(K - T) % length].index
  * 1 = array[0].index
```

|최소힙||
|-|-|
|array|(3, 1)|
|K|5초|
|length|1개|
|P|2초|
|T|5초|
|return|1|

---

### 효율성 테스트 통과를 위한 리팩토링

* k = 5
* food_times [3, 1, 2]
  * food_times[0] = 3
  * food_times[1] = 1
  * food_times[2] = 2
* row = 시간 (0 -> x)
* column = 음식 섭취 시간 (0 -> -y)

|0|1|2|
|-|-|-|
|1|1|1|
|2|-|2|
|3|-|-|

`column = 음식 섭취 시간 카운트 (0 -> -y)`
|0|1|2|
|-|-|-|
|1|2|3|
|4|-|5|
|6|-|-|

`문제점 = 테이블 만큼 연산을 반복하게 됨`

### 효울성 테스트 해결방안

* 음식 남은 시간 기준 오름차순 정렬

```txt
0.
* 음식 남은 시간 기준 오름차순 정렬
  * food_times [3, 1, 2]
  * food_times[1] = 1
  * food_times[2] = 2
  * food_times[0] = 3
* row = 시간 (0 -> x)
* column = 음식 섭취 시간 (0 -> -y)
  
```

|1|2|0|
|-|-|-|
|1|1|1|
|-|2|2|
|-|-|3|

```txt
1.
* row[0] 연산
  * K = K - (row.length x column.length)
  * 2 = 5 - (3 x 1) 
```

|1|2|0|
|-|-|-|
|*1|*1|*1|
|-|2|2|
|-|-|3|

```txt
2.
* row[1] 연산
  * K = K - (row.length x column.length)
  * 0 = 2 - (2 x 1)
* K <= 0
  * 순회 중단
```

|1|2|0|
|-|-|-|
|*1|*1|*1|
|-|*2|*2|
|-|-|3|

```txt
2.
* row[1] 연산
  * K = K - (row.length x column.length)
  * 0 = 2 - (2 x 1)
* K <= 0
  * 순회 중단
```

|1|2|0|
|-|-|-|
|*1|*1|*1|
|-|*2|*2|
|-|-|3|

```txt
3. 
* 남은 음식은 index 기준으로 재정렬하여 리스트에 담음
* 남은 음식 리스트의 길이 N
* 다음 먹어야 할 음식을 구하는 연산
  * K = K % N 
  * 0 = 0 % 1 
* 남은음식리스트[0].index = 1
* 정답 = 1
```
