# 특정 거리의 도시 찾기

## 문제 설명

* 1 ~ N번까지의 도시와 M개의 방향 도로가 존재함
* 모든 도로의 거리는 1
* X = 출발 도시
* K = 최단 거리
* X에서 X로 가는 최단거리는 항상 0

`X로 부터 출발하여 도달할 수 있는 도시 중 최단거리가 정확히 K인 모든 도시의 번호를 출력하시오`

입력 조건

* 첫째 줄에 N, M, K, X 가 공백으로 구분되어 주어짐
  * 2 <= N <= 30,000
  * 1 <= M <= 1,000,000
  * 1 <= K <= 300,000
  * 1 <= X <= N
* 둘째 줄부터 M개의 줄에 걸쳐 자연수 A, B가 공백으로 구분되어 주어짐
  * A번 도시에서 B번 도시로 이동하는 단방향 도로가 존재한다는 의미
  * A와 B는 서로 다른 자연수
  * 1 <= A, B <= N

```txt
4 4 2 1
1 2
1 3
2 3
2 4
```

출력 조건

* X로부터 출발하여 도달할 수 있는 도시 중 최단거리가 K인 모든 도시번호를 한 줄에 하나씩 오름차순 출력
* 최단 거리가 K인 도시가 하나도 존재하지 않는 경우 -1 출력

```txt
4
```

### 해결 과정

* 모든 도로의 거리 = 1
  * 모든 간선의 비용 = 1
  * 그래프에서 모든 간선의 비용이 동일한 경우 너비 우선 탐색(BFS)를 이용하여 최단 거리를 찾을 수 있음
* 시간 복잡도 O(N + M)
* 특정도시 X를 시작점으로 BFS수행
  * 모든 도시의 최단거리 계산
  * 최단거리를 하나씩 확인하여 값이 K인 경우 도시의 번호를 출력

```txt
0.

* 입력
6 6 2 1
1 2
1 3
2 4
3 5
4 6
5 6
* 최단거리(k) = 2
* 출발도시(x) = 1
* graph = [[], [2, 3], [4], [5], [6], [6], []]
* distance = [-1, 0, -1, -1, -1, -1, -1]
* queue.push(출발도시(x)=1) 
```

```txt
1.

* graph = [[], [2, 3], [4], [5], [6], [6], []]
* distance = [-1, 0, -1, -1, -1, -1, -1]
* queue.pop() -> 현재 도시 = 1
* 현재 도시의 간선 정보 = [2, 3]
  * distance[2] = -1 (방문하지 않음)
  * 방문하지 않은 도시 최단거리 갱신 = 현재도시 최단거리 + 1 = 1
  * distance[3] = -1 (방문하지 않음)
  * 방문하지 않은 도시 최단거리 갱신 = 현재도시 최단거리 + 1 = 1
* update distance = [-1, 0, 1, 1, -1, -1, -1]
* queue.push(next=2)
```

```txt
2.

* graph = [[], [2, 3], [4], [5], [6], [6], []]
* distance = [-1, 0, 1, 1, -1, -1, -1]
* queue.pop() -> 현재 도시 = 2
* 현재 도시의 간선 정보 = [4]
  * distance[4] = -1 (방문하지 않음)
  * 방문하지 않은 도시 최단거리 갱신 = 현재도시 최단거리 + 1 = 2
* update distance = [-1, 0, 1, 1, 2, -1, -1]
* queue.push(next=3)
```

```txt
3.

* graph = [[], [2, 3], [4], [5], [6], [6], []]
* distance = [-1, 0, 1, 1, 2, -1, -1]
* queue.pop() -> 현재 도시 = 3
* 현재 도시의 간선 정보 = [5]
  * distance[5] = -1 (방문하지 않음)
  * 방문하지 않은 도시 최단거리 갱신 = 현재도시 최단거리 + 1 = 2
* update distance = [-1, 0, 1, 1, 2, 2, -1]
* queue.push(next=4)
```

```txt
4.

* graph = [[], [2, 3], [4], [5], [6], [6], []]
* distance = [-1, 0, 1, 1, 2, 2, -1]
* queue.pop() -> 현재 도시 = 4
* 현재 도시의 간선 정보 = [6]
  * distance[6] = -1 (방문하지 않음)
  * 방문하지 않은 도시 최단거리 갱신 = 현재도시 최단거리 + 1 = 3
* update distance = [-1, 0, 1, 1, 2, 2, 3]
* queue.push(next=5)
```

```txt
5.

* graph = [[], [2, 3], [4], [5], [6], [6], []]
* distance = [-1, 0, 1, 1, 2, 2, 3]
* queue.pop() -> 현재 도시 = 5
* 현재 도시의 간선 정보 = [6]
  * distance[6] = 방문 완료
* queue.push(next=6)
```

```txt
6.

* graph = [[], [2, 3], [4], [5], [6], [6], []]
* distance = [-1, 0, 1, 1, 2, 2, 3]
* queue.pop() -> 현재 도시 = 6
* 현재 도시의 간선 정보 = 없음
* queue.push(next=6)
```

```txt
7.

* distance = [-1, 0, 1, 1, 2, 2, 3]
* 최단거리(k) = 2
* 최단거리에 속하는 도시는 4, 5

출력
4
5
```
