# 괄호 변환

## 문제 설명

* 소스코드 내 작성된 괄호의 개수가 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 발생하는 상황
* 소스코드에 작성된 모든 괄호를 뽑아 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램 필요
* 용어
  * `'('` and `')'`이 각각의 개수가 같은 문자열 = 균형잡인 괄호 문자열
    * ex -> `(()))(`
  * `'('` and `')'`이 개수와 괄호의 짝도 모두 맞을 경우 = 올바른 괄호 문자열
    * ex -> `(())()`
* `'('` and `')'`로만 이루어진 균형잡힌 문자열 = w
  * w의 올바른 괄호 문자열 변환 과정
    * 입력이 빈 문자열인 경우 빈 문자열 반환
    * 문자열 w를 균형잡힌 괄호 문자열 u, v로 분리
      * u는 균형잡힌 괄호 문자열로 더 이상 분리할 수 없어야 함
      * v는 빈 문자열이 될 수 있음
    * 수행 결과 문자열을 u에 이어 붙인 후 반환
      * 문자열 u가 올바른 괄호 문자열 이라면 v에 대해 1단계부터 다시 수행
    * 문자열 u가 올바른 괄호 문자열이 아닌 경우
      * 빈 문자열에 첫 번째 문자로 `'('`를 붙임
      * 문자열 v에 대해 1단계부터 재귀적 수행 결과 문자열을 이어 붙임
      * `')'`를 다시 붙임
      * u 의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어 뒤에 붙임
      * 생성된 문자열 반환

`균형잡힌 괄호 문자열 p가 매개변수로 주어질 때, 올바른 괄호 문자열로 변환한 결과를 return하도록 solution 함수를 작성하시오`

매개 변수

* p = `'('` and `')'`로만 이루어진 문자열
  * 2 <= p <= 1,000 (짝수)
* 문자열 p를 이루는 `'('` and `')'`의 개수는 항상 같음
* p가 이미 올바른 괄호 문자열이라면 그대로 return

입력

`()))((()`

출력

`()(())()`

### 해결 과정

* 문제에서 구현을 위한 알고리즘을 정확하게 제시하고 있으므로 그대로 구현하면 성공함
  * 구현문제로 분류할 수 있음
* 알고리즘 자체가 DFS의 핵심인 재귀 함수 구현을 요구하므로 DFS 문제로 분류 가능

```txt
0.
* Java 기준으로 설명
* 입력 = "()))((()"
* dfs(char[] wArray) -> 재귀함수 -> answer return
  * 입력되는 wArray를 uArray, vArray로 분리
    * uArray = 균형잡힌 괄호 문자열로 더 이상 분리할 수 없어야 함
    * vArray = 빈 문자열이 될 수 있음
  * uArray = 올바른 괄호 문자열
    * answer += new String(uArray) + dfs(vArray)
    * uArray 문자열을 answer에 추가하고 남아있는 vArray에 대하여 dfs 재귀수행
  * uArray != 올바른 괄호 문자열
    * answer에 첫 번째 문자로 `'('`를 붙임
    * answer에 dfs(vArray) 수행 결과 문자열을 이어 붙임
    * answer에 `')'`를 다시 붙임
    * abswer에 uArray 의 첫 번째와 마지막 문자를 제거하고, 남아있는 문자열의 괄호 방향을 뒤집어 이어 붙임
  * 생성된 문자열 반환

1.
* dfs(wArray) = [(, ), ), ), (, (, (, )]
* uArray = [(, )]
* vArray = [), ), (, (, (, )]
* uArray = [(, )] -> verification(true)
  * uArray == 올바른 괄호 문자열
    * answer1 = "()"
  * 이어지는 문자열에 대한 재귀함수 호출
  * call dfs([), ), (, (, (, )])

2.
* dfs(wArray) = [), ), (, (, (, )]
* uArray = [), ), (, (]
* vArray = [(, )]
* uArray = [), ), (, (] -> verification(false)
  * uArray != 올바른 괄호 문자열
    * 문제에서 제시하는 알고리즘 적용
    * answer2 = "(())"
  * 이어지는 문자열에 대한 재귀함수 호출
  * call dfs([(, )]) 

3.
* dfs(wArray) = [(, )]
* uArray = [(, )]
* vArray = []
* uArray = [(, )] -> verification(true)
  * uArray == 올바른 괄호 문자열
    * answer3 = "()"
    * 이어지는 문자열이 비어있으므로 재귀함수 호출 x

4. 
* 3번 수행 결과
  * answer3 = "()"
  * 2번으로 answer3 리턴

5.
* 2번 수행 결과
  * answer2 = "(())" + answer3 = "(())()"
  * 1번으로 answer2 리턴

6.
* 1번 수행 결과
  * answer1 = "()" + answer2 = "()(())()"
  * answer1 리턴

7.
* 출력
"()(())()"
```
