# 미로 탈출

## 문제 설명

* 미로의 크기 N x M
* 괴물이 존재하는 영역 = 0
* 괴물이 존재하지 않은 영역 = 1
* 미로는 반드시 탈출할 수 있는 형태로 제시됨
* 출발 좌표는 (1, 1)
* 출구는 (N, M)
* 한번에 한 칸씩 이동할 수 있음

`최소로 칸을 이동하여 괴물을 피해 탈출하시오.`

입력조건

* 첫 번째 줄에 미로의 세로(N)와 가로(M) 길이가 공백으로 주어짐(4 <= N, M <= 200)
* 두 번째 줄부터 N개의 줄에 각각 M개의 정수 0 or 1로 공백없이 주어짐
* 시작 칸과 마지막 칸은 항상 1

```txt
5 6
101010
111111
000001
111111
111111
```

출력조건

* 첫째 줄에 최소 이동 칸의 개수 출력

```txt
10
```

### `BFS 해결 과정`

입력예시

```txt
3 3
110
101
111
```

```txt
1. map[0][0] = 1 / 시작지점
Queue[]
[*1,1,0]
[1,0,1]
[1,1,1]

---

2. map[0][0] 상, 하, 좌, 우 확인
(상) map[-1][0] = map을 벗어남
(하) map[1][0] = 1 / 방문체크 1 + 1 = 2 / Push((1, 0))
Queue[(1, 0)]
[1,1,0]
[*2,0,1]
[1,1,1]
(좌) map[0][-1] = map을 벗어남
(우) map[0][1] = 1 / 방문체크 1 + 1 = 2 / Push(0, 1)
Queue[(1, 0), (0, 1)]
[1,*2,0]
[2,0,1]
[1,1,1]

---

3. Queue Pop() = map[1][0] 상, 하, 좌, 우 확인
Queue[(0, 1)]
[1,2,0]
[*2,0,1]
[1,1,1]
(상) map[0][0] = 1 / 방문체크 2 + 1 = 3 / Push(0, 0)
Queue[(0, 1), (0, 0)]
[*3,2,0]
[2,0,1]
[1,1,1]
(하) map[2][0] = 1 / 방문체크 2 + 1 = 3 / Push(2, 0)
Queue[(0, 1), (0, 0), (2, 0)]
[3,2,0]
[2,0,1]
[*3,1,1]
(좌) map[-1][1] = map을 벗어남
(우) map[1][1] = 0

---

3. Queue Pop() = map[0][1] 상, 하, 좌, 우 확인
Queue[(0, 0), (2, 0)]
[3,*2,0]
[2,0,1]
[3,1,1]

(상) map[-1][1] = map을 벗어남
(하) map[1][1] = 0
(좌) map[0][0] = 3
(우) map[0][2] = 0

---

4. Queue Pop() = map[0][0] 상, 하, 좌, 우 확인
Queue[(2, 0)]
[*3,2,0]
[2,0,1]
[3,1,1]

(상) map[-1][0] = map을 벗어남
(하) map[1][0] = 2
(좌) map[0][-1] = map을 벗어남
(우) map[0][1] = 2

4. Queue Pop() = map[2][0] 상, 하, 좌, 우 확인
Queue[]
[3,2,0]
[2,0,1]
[*3,1,1]

(상) map[1][0] = 2
(하) map[3][0] = map을 벗어남
(좌) map[2][-1] = map을 벗어남
(우) map[2][1] = 1 / 방문체크 3 + 1 = 4 / push(2, 1)
Queue[(2, 1)]
[3,2,0]
[2,0,1]
[3,*4,1]

5. Queue Pop() = map[2][1] 상, 하, 좌, 우 확인
Queue[]
[3,2,0]
[2,0,1]
[3,*4,1]

(상) map[1][1] = 0
(하) map[3][1] = map을 벗어남
(좌) map[2][0] = 3
(우) map[2][2] = 1 / 방문체크 4 + 1 = 5 / Push(2, 2)
Queue[(2, 2)]
[3,2,0]
[2,0,1]
[3,4,*5]

6. Queue Pop() = map[2][2] 상, 하, 좌, 우 확인
Queue[]
[3,2,0]
[2,0,1]
[3,4,*5]

(상) map[1][2] = 1 / 방문체크 5 + 1 = 6 / Push(1, 2)
Queue[(1, 2)]
[3,2,0]
[2,0,*6]
[3,4,5]
(하) map[3][2] = map을 벗어남
(좌) map[2][1] = 4
(우) map[2][3] = map을 벗어남

7. Queue Pop() = map[1][2] 상, 하, 좌, 우 확인
Queue[(1, 2)]
[3,2,0]
[2,0,*6]
[3,4,5]

(상) map[0][2] = 0
(하) map[2][2] = 5
(좌) map[1][1] = 0
(우) map[1][3] = map을 벗어남

8. Queue Empty
출구 = map[n - 1][m - 1]
map[2][2] = 5
[3,2,0]
[2,0,6]
[3,4,*5]

5를 출력한다
```
