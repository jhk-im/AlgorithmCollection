# 정렬(Sorting)

## 정렬 알고리즘 개요

* 데이터를 특정한 기준에 따라 순서대로 나열함
* 프로그램 작성 시 가장 많이 사용되는 알고리즘
* 정렬 알고리즘으로 이진 탐색(Binary Search) 구현
* 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬

---
### 선택 정렬(Selection Sort)

* 가장 작은 데이터를 선택하여 맨 앞에 있는 데이터와 바꿈
* 그 다음 가장 작은 것을 선택하여 두 번째 데이터와 바꿈
* 위 과정을 반복

```txt
1. 가장 작은 데이터를 선택
[5][3][1][*0][2]

2. 맨 앞에 있는 데이터와 바꿈
[*0] [3][1][5][2]

3. 두 번째로 작은 데이터를 선택
[0] [3][*1][5][2]

4. 아직 자리를 바꾸지 않은 데이터 중 맨 앞에 있는 데이터와 바꿈
[0][*1] [3][5][2]

5. 세 번째로 작은 데이터 선택
[0][1] [3][5][*2]

6. 아직 자리를 바꾸지 않은 데이터 중 맨 앞에 있는 데이터와 바꿈
[0][1][*2] [5][3]

7. 네 번째로 작은 데이터 선택
[0][1][2] [5][*3]

8. 아직 자리를 바꾸지 않은 데이터 중 맨 앞에 있는 데이터와 바꿈
[0][1][2][*3] [5]

9. 마지막 데이터 이므로 정렬 종료
[0][1][2][3][*5]
```

### 선택 정렬의 시간 복잡도

* 2중 반복문
* N - 1 번 만큼 가장 작은 수를 찾아 맨 앞으로 보내야 함
* 매번 가장 작은 수를 찾기 위한 비교 연산
* N + (N - 1) + (N - 2) ... + 2
* (N² + N) / 2 = O(N²)
* 선택 정렬은 기본 정렬 라이브러리를 포함
* 다른 정렬 알고리즘과 비교하면 비효율적
* 가장 작은 데이터를 찾는 일이 많으므로 익숙해질 필요가 있음

---

### 삽입 정렬(Insert Sort)

* 데이터를 하나씩 확인하여 각 데이터를 적절한 위치에 삽입
* 선택 정렬보다 구현 난이도가 높지만 실행 시간 측면에서 효율적

```txt
1. 첫 번째 데이터는 정렬되어 있다 판단하고 두번 째 데이터 시작
[5][*3][1][0][2]

2. 두 번째 데이터가 어떤 위치에 들어갈지 판단
[*3][5] [1][0][2]

3. 다음 데이터가 어떤 위치에 들어갈지 판단
[3][5] [*1][0][2]
[*1][3][5] [0][2]

4. 다음 데이터가 어떤 위치에 들어갈지 판단
[3][5][1] [*0][2]
[*0][1][3][5] [2]

5. 다음 데이터가 어떤 위치에 들어갈지 판단
[3][5][1][0] [*2]
[0][1][*2][3][5]

* 정렬이 이루어진 원소는 오름차순을 유지함
* 삽입될 데이터보다 작은데이터를 만나면 그 위치에 삽입
```

### 삽입 정렬의 시간 복잡도

* 2중 반복문
* O(N²)
* 선택 정렬과 흡사한 시간 소요
* 거의 정렬되어 있는 상태에서는 매우 빠르게 동작함
* 최선의 경우 O(N)

---

### 퀵 정렬

* 가장 많이 사용되는 정렬 알고리즘
* 기준 데이터(피벗)를 설정
* 피벗보다 큰 데이터와 작은 데이터의 위치를 바꿈
* Hoare Partion 방식을 사용
* 리스트에서 첫 번째 데이터를 피벗으로 정함

```txt
Part1

1. 첫 번째 데이터를 피벗으로 설정
[*5][7][1][0][8][3][2][4]

2-1. 피벗을 제외하고 왼쪽 부터 피벗보다 큰 데이터 선택
[*5] [*7][1][0][8][3][2][4]
2-2. 오른쪽 부터 피벗보다 작은 데이터 선택
[*5] [*7][1][0][8][3][2][*4]
2-3. 두 데이터의 위치 변경
[*5] [*4][1][0][8][3][2][*7]

3-1. 다시 왼쪽 부터 피벗보다 큰 데이터 선택
[*5] [4][1][0][*8][3][2][7]
3-2. 오른쪽 부터 피벗보다 작은 데이터 선택
[*5] [4][1][0][*8][3][*2][7]
3-3. 두 데이터의 위치 변경
[*5] [4][1][0][*2][3][*8][7]

4-1. 다시 왼쪽 부터 피벗보다 큰 데이터 선택
[*5] [4][1][0][2][3][*8][7]
4-2. 오른쪽 부터 피벗보다 작은 데이터 선택
[*5] [4][1][0][2][*3][*8][7]
4-3. 두 데이터가 이미 바꾼 상태인 것과 같을 땐 작은 데이터를 피벗과 변경하여 분할
[*3][4][1][0][2] [*5] [8][7]
4-4. 피벗 제외하고 원소가 2개인 경우 비교하여 정렬
[3][4][1][0][2] [*5][*7][*8]

5. 피벗 기준 왼쪽 리스트에서 다시 피벗 설정
[*3][4][1][0][2] [*5][*7][*8]

6-1. 피벗을 제외하고 왼쪽 부터 피벗보다 큰 데이터 선택
[*3] [*4][1][0][2] [*5][*7][*8]
6-2. 오른쪽 부터 피벗보다 작은 데이터 선택
[*3] [*4][1][0][*2] [*5][*7][*8]
6-3. 두 데이터의 위치 변경
[*3] [*2][1][0][*4] [*5][*7][*8]

7-1. 다시 왼쪽 부터 피벗보다 큰 데이터 선택
[*3] [2][1][0][*4] [*5][*7][*8]
7-2. 오른쪽 부터 피벗보다 작은 데이터 선택
[*3] [2][1][*0][*4] [*5][*7][*8]
7-3. 두 데이터가 이미 바꾼 상태인 것과 같을 땐 작은 데이터를 피벗과 변경하여 분할
[*0][2][1] [*3] [4] [*5][*7][*8]

8-1. 피벗 제외 원소가 1인 경우 완료된 것으로 간주
[*0][2][1] [*3][*4][*5][*7][*8]
8-2. 피벗 제외하고 원소가 2개인 경우 비교하여 정렬
[*0][*1][*2][*3][*4][*5][*7][*8]

정렬 완료 
[0][1][2][3][4][5][7][8]
```

### 퀵 정렬의 시간 복잡도

* 평균 시간 복잡도 O(NlogN)
* 최악의 경우 O(N²)
* 퀵 정렬의 시간 복잡도 증명을 자세히 알지 못해도 크게 무리는 없음
* 데이터 개수가 많을수록 선택, 삽입 정렬에 비해 압도적으로 빠름
* 이미 데이터가 정렬되어 있는 경우 느리게 동작함

---

### 계수 정렬(Count Sort)

* 데이터의 크기 범위가 제한되어 정수형태로 표현할 수 있을 때 사용가능
* 매우 빠른 정렬 알고리즘
* 데이터 개수 N, 최대값 K일 때 O(N + K) 보장
* 일반적으로 가장 작은 데이터와 큰 데이터의 차가 1,000,000을 넘지 않을 때 효과적으로 사용
* 모든 범위를 담을 수 있는 크기의 리스트 선언

```txt
1. 가장 큰 데이터와 가장 작은 데이터의 범위가 담길 수 있는 리스트 생성
[7, 5, 9, *0, 3, 1, 6, 2, *9, 1, 4, 8, 0, 5, 2]
[0][1][2][3][4][5][6][7][8][9]

2. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스에 데이터 1 증가
[*7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
[0][1][2][3][4][5][6][7][8][9]
[0][0][0][0][0][0][0][1][0][0]

[*7, *5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
[0][1][2][3][4][5][6][7][8][9]
[0][0][0][0][0][1][0][1][0][0]

- 반복 -

[*7, *5, *9, *0, *3, *1, *6, *2, *9, *1, *4, *8, *0,*5, *2]
[0][1][2][3][4][5][6][7][8][9]
[2][2][2][1][1][2][1][1][1][2]

3. 첫 번째 리스트 부터 데이터 값 만큰 인덱스를 출력
[*0][1][2][3][4][5][6][7][8][9]
[*2][2][2][1][1][2][1][1][1][2]
출력 결과 : 00

[*0][*1][2][3][4][5][6][7][8][9]
[*2][*2][2][1][1][2][1][1][1][2]
출력 결과 : 0011

- 반복 -
[*0][*1][*2][*3][*4][*5][*6][*7][*8][*9]
[*2][*2][*2][*1][*1][*2][*1][*1][*1][*2]
출력 결과 : 001122345567899
```

### 계수 정렬의 시간 복잡도

* O(N + K)
* 기수 정렬(Radix Sort)과 함께 가장 빠른 정렬 알고리즘

### 계수 정렬의 공간 복잡도

* O(N + K)
* 데이터가 0, 999 단 2개만 존재한다고 가정했을 때 리스트 크기가 100만 개가 되도록 선언해야 함
* 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합
* 데이터 크기가 한정되어 있고 중복이 있을 수록 유리함

### [example1](https://github.com/jhk-im/algorithm-collection/tree/main/ndb/04_sorting/%08example1)
